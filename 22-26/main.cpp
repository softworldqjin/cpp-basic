#include <stdio.h> // 컴파일 할 때는 각 파일마다 .obj파일 만듦
#include "func.h" // Add() 선언 복붙 -> 호출 가능, 컴파일 타임 OK
				  // 링크 타임에 실제 구현된 소스코드 찾아서 .obj파일과 .lib파일 합쳐서 실행파일 만듦.

#include "common.h" // 정적변수 선언한 헤더파일 전처리(복붙)한다. == 선언 및 정의를 여기서 또 한 것
					// 정적변수는 선언된 파일에서만 인식 및 접근 가능

					
// 변수 종류 -> (변수명)이 변수 무슨 변수야? 물으면 변수 종류를 말하면 됨.
// 
// 1. 지역변수		  - 스택 영역
// 2. 전역변수		  - 데이터 영역
// 3. 정적변수(static) - 데이터 영역
// 4. 외부변수(extern) - 데이터 영역

// 메모리 영역
// 1. 스택 영역
// 2. 힙 영역
// 3. 데이터 영역
// 4. 읽기 전용(코드, ROM)

int g_i = 0; // 데이터 영역
			 // 전역변수가 같은 이름을 가지면 구별 못함.
			 // 
			 // main.cpp에서만 전역변수 g_i 앎, 개발하는 과정에서 다른 파일에선 인식 불가능
			 // 다른 파일에서는 g_i를 건들이지 못하는거지.
			 // 그래서 다른 파일에서 건들일 수 있게 **외부변수 선언 extern g_i** 를 쓰는거임
			 // 빌드타임되고 나선 존재하긴 해.

// Data 영역 특징
// 프로그램 시작 시 생성
// 프로그램 종료 시 해제
// 그렇다면 전역변수는 프로그램 실행 중에 계속 존재한다. -> 계속 존재해야되는 데이터를 데이터 영역에 올리자


void Test_() //Test()함수 호출할 때 마다 스택 영역에 i 변수 생기고 사라지고, 반복
{
	int i = 0;
	++i;
}

void Test_r() //Test_r()함수 호출할 때 마다, 데이터 영역에 있는 g_i 1증가
{
	++g_i;
}


//정적변수 - 데이터 영역
//해당 파일에서만 인식가능, 같은 변수이름이더라도 다른 파일에 있다면, 다른 거임
//func.cpp에서 선언된 static g_iStatic과 main.cpp에서 선언된 static g_iStatic은 다른거임
//같은 이름이더라도 구별이 가능한거임, 중복 정의 문제가 발생하지 않음


int Test() // 정적변수는 해당 함수 안에서만 사용 가능
		   // 프로그램이 종료할 때 까지 데이터 영역에 살아있는 거임
{
	static int j = 0; //처음에 선언 및 정의, 반복하지 않음

	++j; //여기서만 접근 가능
	++g_i;

	return j;
}

int main()
{
	
	g_iStatic = 100;

	// F12 선언된 위치로 이동 (정의 > 선언)
	Add(0, 0);

	//지역변수

	int i = Mul(10, 20);

	Test_(); //호출하는 순간 정적변수 - 데이터 영역에 생성
			//stack에는 a 생성
			
	// j = 1; 정적변수는 해당 함수에서만 사용 가능
	//		  main() 함수에서 i 접근 불가

	Test();
	Test();
	
	printf("접근 횟수: %d\n", g_i);

	g_i = 0;
	printf("임의 수정한 횟수: %d\n", g_i); //전역 변수는 접근(수정)이 가능하다.
										 //그렇다면 정적변수는 해당 함수에서만 접근이 가능하다!
										 //접근 방지할 수 있는 기능이 있다는 것

	int k = Test(); //Test()는 총 3번 실행함

	printf("정적변수의 상태는?: %d\n", k);
	
	//외부 변수
	printf("링크 타임 완료, 외부변수(g_.cpp에서 정의해놓은) g_iExtern: %d\n", g_iExtern);

	return 0;
}