#pragma once

template<typename T>
struct tListNode
{
// 기본 접근 지정자 public:
	T				data;
	tListNode<T>*	pPrev;
	tListNode<T>*	pNext;

	// 기본 생성자
	tListNode()
		: data()
		, pPrev(nullptr)
		, pNext(nullptr)
	{

	}

	// 생성자도 오버로딩 가능
	tListNode(const T& _data, tListNode<T>* _pPrev, tListNode<T>* _pNext)
		: data(_data)
		, pPrev(_pPrev)
		, pNext(_pNext)
	{

	}
};

template<typename T>
class CList
{
// 기본 접근 지정자 private:
private:
	tListNode<T>*	m_pHead; // tListNode<float> 구조체 정의 생김, m_pHeadNode = nullptr;
	tListNode<T>*	m_pTail;
	int				m_iCount;

public:
	void push_back(const T& _data);
	void push_front(const T& _data);

public:
	CList();
	~CList();
};

template<typename T>
void CList<T>::push_back(const T& _data)
{	
	// 입력된 데이터를 저장할 노드를 동적할당 함
	tListNode<T>* pNewNode = new tListNode<T>(_data, nullptr, nullptr); // tListNode(a,a,a) 생성자 호출
	// pNewNode->data = _data;
	// pNewNode->pPrev = nullptr;
	// pNewNode->pNext = nullptr;

	// 처음 입력된 데이터라면
	if (m_pHead == nullptr)
	{
		// 처음 입력된 데이터라면
		m_pHead = pNewNode;
		m_pTail = pNewNode;
	}
	else
	{
		// 데이터가 1개 이상에서 입력된 경우.. 마지막 노드를 알아야 연결할 수 있음
		// 현재 가장 마지막 데이터(tail)를 저장하고 있는 노드가
		// 새로 생성된 노드가 서로 가리키게 한다.
		m_pTail->pNext = pNewNode;
		pNewNode->pPrev = m_pHead;

		// 마지막 노드를 새로 동적할당된 주소로.. 
		m_pTail = pNewNode;
	}
	// 데이터 개수 증가
	++m_iCount;
}

template<typename T>
void CList<T>::push_front(const T& _data)
{	
	// 새로 생성된 노드의 다음을 현재 헤드노드의 주소값으로 저장
	tListNode<T>* newNode = new tListNode<T>(_data, nullptr, m_pHead);

	// 현재 헤드노드의 앞을 새로 생성된 노드로 저장
	m_pHead->pPrev = newNode;

	// 현재 헤드노드를 새로 생성된 주소값으로 저장
	m_pHead = newNode;

	// 데이터 개수 증가
	++m_iCount;
}

template<typename T>
CList<T>::CList()
	: m_pHead(nullptr)
	, m_pTail(nullptr)
	, m_iCount(0)
{

}

template<typename T>
CList<T>::~CList()
{
	tListNode<T>* pDeleteNode = m_pHead;
	tListNode<T>* pNext = nullptr;

	while (pDeleteNode)
	{
		pNext = pDeleteNode->pNext;
		delete pDeleteNode;
		pDeleteNode = pNext;
	}
}

